---
description: RPGJS v4 development toolkit — patterns, gotchas, and reference
globs: "**/*.{ts,tsx,vue,toml,tmx}"
alwaysApply: false
---

# RPGJS v4 Development Toolkit

## Local Reference

The full RPGJS v4.3.1 source and documentation are available locally at
`docs/rpgjs-reference/`. Use these as your primary reference:

- **Guide docs**: `docs/rpgjs-reference/docs/guide/` — tutorials and conventions
- **API docs**: `docs/rpgjs-reference/docs/api/` — API reference
- **Server source**: `docs/rpgjs-reference/packages/server/` — server internals
- **Client source**: `docs/rpgjs-reference/packages/client/` — client internals
- **Sample project**: `docs/rpgjs-reference/packages/sample2/main/` — complete working example
- **Dev guide**: `docs/rpgjs-guide.md` — extracted cheat sheet

When implementing RPGJS features, **read the relevant local docs first** before
writing code. Do not guess at APIs — verify against the reference.

## Autoload Convention (Critical)

RPGJS v4 auto-discovers files by directory placement. The directory names
matter — files in the wrong location won't be registered.

### Required Directory Names (under module root)
```
events/         → @EventData classes auto-registered
maps/           → @MapData classes auto-registered
database/       → @Item, @Weapon, etc. auto-registered
spritesheets/   → Spritesheet definitions auto-registered
gui/            → Vue/React components auto-registered
sounds/         → Audio files auto-registered
worlds/         → World map files auto-registered
```

### Hook Files (flat at module root)
```
player.ts       → RpgPlayerHooks export
server.ts       → RpgServerEngineHooks export
client.ts       → RpgClientEngineHooks export
sprite.ts       → RpgSpriteHooks export
scene-map.ts    → RpgSceneMapHooks export
```

### Spritesheet Naming
- The **filename** of the PNG image becomes the graphic ID
- `spritesheets/npc/male.png` → use `setGraphic('male')`
- One `.ts` definition file per spritesheet folder

## Event Creation Pattern

```ts
import { RpgEvent, EventData, RpgPlayer, EventMode, Speed,
         Move, Components, ShapePositioning } from '@rpgjs/server'

@EventData({
    name: 'EV-UNIQUE-NAME',         // Must match Tiled object name
    mode: EventMode.Shared           // Default — one instance for all players
})
export default class MyNpcEvent extends RpgEvent {
    onInit() {
        this.setGraphic('sprite-id') // Matches spritesheet PNG filename
        this.setHitbox(16, 16)
        this.speed = Speed.Slow
    }

    async onAction(player: RpgPlayer) {
        await player.showText('Hello!', { talkWith: this })
    }
}
```

### Event Placement in Tiled
- Add an Object Layer to your .tmx map
- Add a Point object with `name` matching the `@EventData.name` value
- The event will spawn at that position on the map

## Quick NPC Generation Tool

**Fastest way to create a new NPC:** Use the template file!

### 5-Minute NPC Creation Workflow

1. **Copy the template:**
   ```bash
   cp .cursor/templates/npc-event.template.ts main/events/{{npc-name}}.ts
   ```
   Example: `cp .cursor/templates/npc-event.template.ts main/events/baker.ts`

2. **Fill in placeholders** (use Find/Replace):
   - `{{EVENT_NAME}}` → `EV-BAKER` (unique event identifier)
   - `{{CLASS_NAME}}` → `BakerEvent` (TypeScript class name)
   - `{{NPC_ROLE}}` → `Baker` (human-readable role, used in logs)
   - `{{NPC_DESCRIPTION}}` → `A friendly baker selling fresh bread`
   - `{{INIT_MESSAGE}}` → `ready to sell bread` (console log message)
   - `{{DIALOGUE_LINE_1}}` → `"Fresh bread, hot from the oven!"`
   - `{{DIALOGUE_LINE_2}}` → `"Would you like a loaf?"`
   - `{{FREQUENCY}}` → `200` (movement frequency in ms, default: 200)
   - `{{DETECTION_SIZE}}` → `100` (detection radius in pixels, default: 100)

3. **Add spawn code to `main/player.ts`:**
   - See `.cursor/templates/npc-spawn-snippet.ts` for exact code
   - Add import: `import BakerEvent from './events/baker'`
   - Add spawn line inside the `onJoinMap` try block:
     ```ts
     map.createDynamicEvent({ x: 250, y: 350, event: BakerEvent })
     console.log('[Baker] Spawned on map:', map.id)
     ```

4. **Done!** The NPC will spawn when players join the map.

### Template Files

- **`.cursor/templates/npc-event.template.ts`** — Complete NPC event class template
- **`.cursor/templates/npc-spawn-snippet.ts`** — Spawn code snippet with instructions

### Customization Options

For advanced customization (different movement patterns, larger detection radius, etc.),
see the detailed "NPC with Patrol and Detection (Proven Pattern)" section below.

## NPC with Patrol and Detection (Proven Pattern)

Use this pattern to create an NPC that patrols randomly, detects nearby
players, and responds to interaction. This is the foundation for all
AI-controlled NPCs.

### Step 1 — Event class in `main/events/`

```ts
import { RpgEvent, EventData, RpgPlayer, Move,
         ShapePositioning, RpgShape } from '@rpgjs/server'

@EventData({
    name: 'EV-MY-NPC',   // Unique event name
    hitbox: { width: 32, height: 16 }
})
export default class MyNpcEvent extends RpgEvent {
    onInit() {
        this.setGraphic('female')           // Spritesheet PNG filename
        this.speed = 1                       // Movement speed
        this.frequency = 200                 // ms between move steps
        this.infiniteMoveRoute([Move.tileRandom()])  // Random patrol
        this.attachShape({                   // Detection radius
            height: 100, width: 100,
            positioning: ShapePositioning.Center
        })
    }
    async onAction(player: RpgPlayer) {
        await player.showText('Hello!', { talkWith: this })
    }
    onDetectInShape(player: RpgPlayer, shape: RpgShape) {
        console.log(`[MyNPC] Player "${player.name}" entered radius`)
    }
    onDetectOutShape(player: RpgPlayer, shape: RpgShape) {
        console.log(`[MyNPC] Player "${player.name}" left radius`)
    }
}
```

### Step 2 — Spawn dynamically in `main/player.ts`

Do NOT create a `@MapData` class for maps loaded via `.world` files — it
causes duplicate registration errors. Instead, spawn NPCs dynamically:

```ts
import MyNpcEvent from './events/my-npc'

const npcSpawnedOnMap: Set<string> = new Set()

// Inside onJoinMap:
const map = player.getCurrentMap<RpgMap>()
if (map && map.id === 'target-map' && !npcSpawnedOnMap.has(map.id)) {
    try {
        map.createDynamicEvent({ x: 200, y: 200, event: MyNpcEvent })
        npcSpawnedOnMap.add(map.id)
    } catch (err) {
        console.error('[MyNPC] Failed to spawn:', err)
    }
}
```

### Key gotchas

- `map.createDynamicEvent()` = Shared mode (all players see it) ✅
- `player.createDynamicEvent()` = Scenario mode (per-player) ❌ for NPCs
- World file maps + `@MapData` class = conflict — use dynamic spawning
- Always wrap spawn logic in try/catch
- Use a `Set` to prevent duplicate spawns on the same map

## Map Creation Pattern

```ts
import { RpgMap, MapData, RpgPlayer } from '@rpgjs/server'

@MapData({
    id: 'map-id',                            // Used in rpg.toml [start.map] and changeMap()
    file: require('../worlds/maps/map.tmx')  // Path to .tmx file
})
export default class TownMap extends RpgMap {
    onJoin(player: RpgPlayer) { }
    onLeave(player: RpgPlayer) { super.onLeave(player) }
}
```

## Synchronization Rules (Must Follow)

### After changeMap — use onJoinMap
```ts
// WRONG — properties set after changeMap() are lost
async onConnected(player) {
    await player.changeMap('medieval')
    player.hp = 500  // NOT SYNCED
}

// RIGHT — set properties in onJoinMap
onJoinMap(player) {
    player.hp = 500  // Properly synced
}
```

### Component Templates — use placeholders
```ts
// WRONG — sends entire structure on every name change
Components.text(player.name)

// RIGHT — only value is sent on change
Components.text('{name}')
```

## Performance Rules (Hard Constraints)

| Rule | Reason |
|------|--------|
| NEVER use `onChanges` for NPC logic | Fires for every event change on the map — O(n²) noise |
| NEVER use `onStep` for agent logic | Fires at 60 FPS — massive waste for AI ticks |
| Use `onDetectInShape` for proximity | Efficient shape-based collision detection |
| Use `setInterval` for idle ticks | 15-second intervals for ambient behavior |
| Use `{property}` template syntax | Efficient incremental sync vs full re-send |
| Keep tileset images ≤ 4096x4096 | WebGL texture size limit |

## Hooks Quick Reference

### Event Hooks (NPC lifecycle)
| Hook | When | Use For |
|------|------|---------|
| `onInit()` | Event created on map | Setup graphics, hitbox, speed, shapes |
| `onAction(player)` | Player presses action key on event | Dialogue, interactions |
| `onDetectInShape(player, shape)` | Player enters attached shape | Proximity awareness |
| `onDetectOutShape(player, shape)` | Player leaves attached shape | End proximity |
| `onPlayerTouch(player)` | Physical collision with player | Use sparingly |

### Player Hooks
| Hook | When | Use For |
|------|------|---------|
| `onConnected(player)` | Player logs in | Set name, graphic, hitbox, initial map |
| `onJoinMap(player, map)` | Player finishes map transition | Set HP, items, map-specific state |
| `onInput(player, {input, moving})` | Player presses a key | Handle action/back/custom inputs |
| `onDisconnect(player)` | Player disconnects | Save state |

### Map Hooks
| Hook | When | Use For |
|------|------|---------|
| `onInit()` | Map loaded into server | Create dynamic shapes |
| `onJoin(player)` | Player enters map | Map-specific setup |
| `onLeave(player)` | Player leaves map | Cleanup |

## Movement Commands

```ts
import { Move, Speed } from '@rpgjs/server'

event.speed = Speed.Slow           // Speed.Slow | Speed.Normal | Speed.Fast
event.infiniteMoveRoute([Move.tileRandom()])   // Patrol
event.moveRoutes([Move.tileUp(), Move.wait(500)])  // Scripted
event.breakRoutes(true)            // Pause movement
event.replayRoutes()               // Resume movement
```

## Dialogue Commands

```ts
// Text
await player.showText('Hello!', { talkWith: this })

// Choices
const { text, index } = await player.showChoices('Pick one:', [
    { text: 'Option A', value: 'a' },
    { text: 'Option B', value: 'b' }
])
```

## Database Patterns

```ts
import { Item } from '@rpgjs/database'

@Item({
    id: 'potion',        // Unique ID for addItem/getItem
    name: 'Potion',
    price: 200,
    hpValue: 100,
    consumable: true
})
export default class Potion { }

// Usage:
await player.addItem(Potion, 1)
const item = player.getItem('potion')
```

## Working with the Agent System

When implementing AI NPC events that connect to the agent system:

1. **NPC event class** lives in `events/` — handles RPGJS lifecycle
2. **Agent logic** lives in `src/agents/` — handles AI behavior
3. **Bridge layer** connects them — `src/agents/bridge/`
4. Events forward `onAction` and `onDetectInShape` to the bridge
5. Agent skills call back into RPGJS APIs (move, showText, etc.)
6. **Agent errors must never crash the game server** — always wrap in try/catch

## In-game builder feature

The in-game builder dashboard uses the same RPGJS features as the rest of the game. Use this approach so builder work stays consistent and reusable.

### Visibility: only me vs everyone

- **Everyone**: `map.createDynamicEvent({ x, y, event: EventClass })` — **EventMode.Shared** (one instance, all players see it).
- **Only me (creator/admin)**: `player.createDynamicEvent({ x, y, event: EventClass })` — **EventMode.Scenario** (per-player instance; only that player sees it).

Dashboard sends `visibility: 'everyone' | 'only-me'`; server chooses map vs player accordingly.

### State and persistence

- **Player variables**: `player.setVariable(key, value)` / `player.getVariable(key)` for builder flags or metadata; included in `player.save()`.
- **Save/load**: `player.save()` returns JSON; persist it (e.g. backend or file). On join, `player.load(json)` restores state. Builder placements can be stored the same way (e.g. keyed by map id or player) and re-applied on map load via `createDynamicEvent`.

### RPGJS guides to use

| Need | Guide |
|------|--------|
| Shared vs Scenario, variables | `docs/rpgjs-reference/docs/guide/create-event.md` |
| Dynamic shapes (optional) | `docs/rpgjs-reference/docs/guide/create-shape.md` |
| save/load, props, sync | `docs/rpgjs-reference/docs/guide/synchronization.md`, `save.md` |
| Key to open builder | `docs/rpgjs-reference/docs/guide/inputs.md` |
| GUI open / handle actions | `docs/rpgjs-reference/docs/commands/gui.md`, `classes/player.md` |
| List/remove events | Map API: `map.events`, `map.removeEvent(eventId)` |

See also: `.cursor/plans/in-game_builder_dashboard_branch_b24d547b.plan.md` for the full implementation plan and references.

## Verifying Your Work

Before considering a task complete:
```bash
rpgjs build          # Must pass
npx tsc --noEmit     # Must pass
rpgjs dev            # Must launch and be playable
```
